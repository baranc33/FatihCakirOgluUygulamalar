
https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

https://www.udemy.com/course/net-core-asenkron-multi-thread-programlama/learn/lecture/20223696?start=0#overview

Bu Konu 2 Kısımdan oluşmaktadır 1. Ksımda işleyişi kabaca kitaptan öğrenip  
2. Ksısımda Derinlemesine işin içine Araştırma yaparak gireceğiz
1.	Kısım
Asenkron Programlama
Otomasyon proramlarında donma gibi sorunların önüne geçebilmek için Eşzamanlı(Synchronized) yerine  Eş zamanlı olmiyan Asenkron(asynchronized) programlama yöntemlerine bırakmış durumdardır  bu programlama yaklaşımını kullanmak için Async ve await Keywordlerinden yararlanacağız
Derleyici Bu 2 keywordü gördüğünde derleme zamanıdna müdehale ederek kodu asenkron yapar 
Bir metodu asyncron yapmak için  geri dönüş tipinin önüne async yazarız
Ve async yapacağımız kodun önünede await keywordü yazarız eğer metodun geri dönüş değeri void ise void yerine task keywordü kullanırız.
•	Asynkron mettotlarda ref veya out keywordleri kullanılamaz
•	Await ten sonra kullanılacak metat butlaka Task<TResult> tipinden olmalıdır
•	Await keywordü asyncron metotların dışında kullanılamaz.

konuyla ilgili bir form uygulaması üstünden örnek yapalım
bi form uygulaması açıyoruz 1 tane url için txbox 1 tane buton
1 de http sayfasını kaynak kodunu çekip dolduracağımız textbox
Bunlar üstünden işlem yapıyoruz test ettim çalışıyor
private void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest=(HttpWebRequest) WebRequest.Create(Url);
            WebResponse response = webRequest.GetResponse();

            using (StreamReader sr= new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }

Bu metot senkrondur şimdi işlemi yaptığımız sitenin internet hızı gibi vs. etmenlere göre hızlı veya yavaş gelebilir
Bekleme esnasında Arayüzle ilgili bütün işlemler bekletilecektir çünkü thread metottan gelecek olan cevabı beklemektecdir GetREsponse gibi metotlar blocker metotlar olarak tanımlanmaktadırlar çünkü kodun ilerleyişini bloklamaktadırlar 
Bunun bir sonucu olarak ekranda donamalar  yaşanabilir hatta işlemin nekadar sürdüğüyle bağlı olarak  Not Responding(uygulama yanıt vermiyor) hatası alabilirz
Bu durum elbetteki kullanıcı tecrübesi açısından istenmeyen bir durumdaur ayrıca aynı kod bloğu içersinde konudan bağımsız başka işleri yürütecek metotlarında işlerini yapmasını engelleyecetir böyle bir durumda sistemimizin sağlıklı çalışmasınıda etkliyeiblir gelin şimdi bu metou asynkron hale getirip  işlemimizi profesyonel hale getirelim

    private async void btnGetir_Click(object sender, EventArgs e)
        {
            string Url = txtUrl.Text;

            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(Url);
            WebResponse response = await webRequest.GetResponseAsync();

            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                txbDescription.Text = sr.ReadToEnd();
            }
        }
Yukardaki yeşil kelimeler öncekine göre değiştirlimiştir.


Asenkron Programlama ve Multi-Thread Programlama
http Kullanarak veri çekmeyle ilgili bir network opersaynonnunda sık sık bu aşamada arka planda ayrı bir thread açıldığı ve veri çekme operasyonu süresince bu thread’in çalışıtğığı düşünülür 
aslında bu işlem sırasında sadece belli noktalarda thread’in devreye girmesi gerekmektedir veteknik olarak tghread bloklamadan bu işin aynı thread içersinde yapılması mümkündür
öncelikle data çekme isteğini gönderdiğimiz andan itibaran zamanında büyük kısmı sunucudan gelecek olan cevabı (response) beklemekle geçer , sunucu tawrafında her hangi bir iş yoktur zaten bundan dolayı, işlem senkron programlama yöntemiyle yapmaya kalkıştığımızda sistem,therad’i uyku durumuna geçirir çünkü thread’in yapacağı herhangi bir iş yoktur  
Asenkrn programlamada bilgisayarın birden çok thread ‘ e ihtiyaç duymamasının bir diğer sebebide ,bilgisayarın network donanımınını bu işin çoğunu tek başına yapabilecek kapasitede olmasıdır veri çekmek için istekete bulunduğumuzda network sürücüsü(driver),network  i donanımını bu işi yapması için gerekli komutları verir.bilgisayarın işlemcisi sadece bu işi yaparken meşgul olur ki , bu işi yapmakta gelecek olan cevabı beklemekten çok daha az vakit alır aynı sekilde network donanımı, sunucu tarafından cevaı aldığında tekrar işlemci deverye girer ama yine burada harcanan süre çok azdır yani işin büyük kısmını network donanımı halleder dolayısıyla birden fazla thread’in çalışmasına gerek yoktur.
Çoğu I/O işlemleri bu şekilde gerçekleşir aynı durumu sabit diskten veri okuma,yazma işlemleri içnde uyarlayaibiliriz bu aşamada işlemci disk sürücüsüne neyin nereye yazılacağını söyler Zamaın büyük kısmı sabit diskin çalışığp verileri yazması esnaısında geçer


Try Catch bloklarındada asynkron metotlar kullanılmakta 
public async void DeleteAll()
        {
            try
            {

            }
            catch (Exception)
            {
                await new Task (()=>LogDb())
            }
        }

        private void LogDb()
        {
            // loglama işlemleri
        }


Caller information Nitelikleri
Bazen uygulamada kimin hangi metodu veya propertyi çağırdığını bilgisine ihtiyaç duyarız bu bilgileri özellikle büyük uygulamalarda uygulamann bakım yapılabilirliği (maintainability) açısından çok önemlidir
çağıranBilgileri(caller information) uygulamamızdaki bugların tesppiti hataların kaydedilmesi , performans ölçümü debug gibi konular için bazen hatati önem taşır bu bilgileri elde etmek için Attribute kullanılır
Eskiden StackTrace ve Stack Frame sınıfları kullanılırken performans düşürücü olduğundan  artık 
Bu attribute yöntemi ile kullanılıyor
Gelin metotlara bakalım
[CallerMemberName]// metot veya propertyi çağıranın adı
            [CallerFilePath]//çağrımı yapan kaynak kodunu içern dosya yolu
            [CallerLineNumber]// çağrım yapan kod satır numarası

Bu nitelikler kullanıldığı zaman c#derleyicisi derleme –zamanında (compile time).
Koda müdahale ediyor ve bu nitelikler kullanıldığı metodun çağrıldığı yerde parameterelere ilgili değerleri belirtiyor dolayısıyla bu niteliklerin kullnımında herhangi bir performans sıkıntısı yaşamıyoruz
Kullanımına örnek
   class Program
    {

        static void Main(string[] args)
        {

            CagiranBilgileriniGoster();
        }
        public static void CagiranBilgileriniGoster
          (
         [CallerMemberName] string cagiranIsmi = null,
         [CallerFilePath] string cagiranDosyaYolu = null,
         [CallerLineNumber] int cagiranSatirNumarası = 0
         )
        {
            Console.WriteLine("Cagiran isim:{0}", cagiranIsmi);
            Console.WriteLine("Cagiran Dosya yolu:{0}", cagiranDosyaYolu);
            Console.WriteLine("Cagiran SatırNumarası:{0}", cagiranSatirNumarası);
        }

    }
Test ettim sorunsuz çalışıyor
Yukardaki kod bloğunu çalıştırdığımız zaman aşağıdaki sonucu elde ederiz
Cagiran isim:Main
Cagiran Dosya yolu:C:\Users\baran\Desktop\1 kişisel Eğitim program\4 Yazılım\Depo\Patika\PatikaCsharp\Test\Program.cs
Cagiran SatırNumarası:17

Bu niteliklerden name niteliği, InofityPropertyChanged arayüzününden implementasyonu oldukça kolaylaştırıyor
Wpf-windowsform gibi teknojilerin binding alt yapısı tarafından kullanılır
Bu konuya girilmemiş bende Web üzerinde gittiğim için araştırmadım

Aşşağıdaki kullanım CallerMemberName olmaksızın yapılan bir örnektir
class Kullanici : INotifyPropertyChanged
    {
        private string _isim;

        public event PropertyChangedEventHandler PropertyChanged;

        public string isim
        {
            get { return _isim; }
            set
            {
                _isim = value;
                OnPropertyChanged(isim);
            }
        }

        protected virtual void OnPropertyChanged(string PropertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            handler(this, new PropertyChangedEventArgs(PropertyName));
        }
    }


INotifyPropertyChanged arayüzü kullanılırken en büyük risk özellik içerisinde özellik ismini onpropertychanged metodunua elle parametre olarak geçmek zunda olmamızdan kaynaklanıyor çünkü özellik ismini yanlış yazılması veya özellik ismini değiştirilip paramtere olarak geçilen imin değiştirilmesi gibi durumlarda söz konusu olabliyor bu riskten kaçınmak için
CallerMemberName niteliğinden faydalanırız
Kodun komplesini tekrar koymican sayfa sayızı artmasın diye metoda attribute ekleniyor sadece
protected virtual void OnPropertyChanged([CallerMemberName]string PropertyName=null)


2.Kısım 
* öncelikle Asenkron programla ile Multi Thread programlama bir birinden tamamen farklı Programlama tarzlarıdır
Asenkron programlamada Threadin bloklanmadan  işlem yapabilmesini sağlar yani tek thread üstünden işlem yapabilmemizi sağlar. Tabi multi thread ilede bu işlemleri yapabiliriz.
Asynron Programlama Task Sınıfı ile kullanılır.

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------